
[В предыдущей главе будет история развития WEB-технологий и другое введение]
Рассмотрим ключевые события в истории WEB-технологий.


Эксперимент 1. Сравнительный анализ скорости вычислений.

Потребление ресурсов центрального процессора является одной из основных характеристик производетельности наряду с потреблением ОЗУ. Исследование скорости вычислений позволит определить набор задач которые будут выполняться в клиентской части приложения за приемлемое время.

Для тестирования производительности возьмём простую вычислительную задачу и проведем серию запусков в различных средах исполнения с произведением замера времени выполнения. Далее вычислим среднее значение, которое и будем считать результатам измерений, а также среднеквадратическое отклонение для определения устойчивости результата.

Исследуемыми средами исполнения будут:
* скриптовый движок браузера для JavaScript, для него будет написан скрип на этом языке
* среда выполнения Mono для браузера исполняющий .NET Standard сборки скомпилированные из исходных кодов на языке C#.
* WebAssembly-движок исполняющий предварительно скомпилированные.NET Standard сборки в поддерживаемый им байт-код.

Вычислительной задачей для проведения тестов будет "определения n-ого простого числа" Возьмем самый простой алгоритм решения этой задачи:

1. Установим значение счетчика равным 0
2. Будем проверять числа начиная с двойки на простоту
3. Увеличим счётчик текущее число простым
4. Если счётчик был увеличен и его значение равного номеру искомого числа, то текущее число является результатом, иначе проверяется следующее простое число.


Простые числа в свою очередь будут проверяться перебором делителей от двойки до квадратного корня от текущего числа. Этот предельно простой алгоритм позволит продемонстрировать разницу в скорости выполнения исследуемый средах средах.

В результате выполнения серия опытов были получены следующие результаты они отображены на графике 1.

[Будут графики зависимости времени выполнения от порядкового номера искомого числа]

Для порядкового номера 100000 были получены следующие результаты среднего значения времени выполнения

WebAssembly: 26 миллисекунд 
JavaScript: 19 миллисекунд
Mono в режиме интерпритации: 524 миллисекунды

Как видно режим интерпретации сборок работает медленнее в среднем 20 раз, однако предварительно скомпилированные сборки работают медленные уже на 25% несмотря на то, что технически код для платформы WebAssembly должен решать аналогичные задачи быстрее кода на JavaScript.

Исследования производительности WebAssembly показывают, что аналогичный код исполняемый в движке JavaScript в среднем на 5 10% медленнее, чем аналогичный собранный для WebAssembly. Данные расхождения связанны с накладными расходами после конвертации сборки WebAssembly байт-код. Если же изначально писать код на языке С++ и скомпилировать его в WebAssembly то его скорость выполнения будет выше, чем у JavaScript. Был написан отдельный тест который показал среднее значение времени выполнения в 17 миллисекунд для аналогичного кода на С++ скомпилированного в WebAssembly байт-код.

Таким образом, выполнение ресурсоемких задач режим интерпретации Mono неприемлемо. Требуется предваритальное прообразование сборки в WebAssembly байт-код и вызовы wasm-кода из кода работающего в режиме интерпретации. Скорость исполнения  WebAssembly-сборок соизмерима со скоростью исполнение кода на языке JavaScript, что позволяет использовать данные фреймворк и язык C# как альтернативую, при условии что весь ресурсоемкий код будет скомпилирован в предварительно в формат WebAssembly байт-код.

Также было замечена важная особенность: первый запуск опыта всегда занимал значительно больше времени чем последующие. Это связано с тем, что первый запуск производит инициализацию исполняемого кода и выполняет JIT-компиляцию в машинный код, а уже последующие запуске используют скомпилированные версии кода. Поэтому для подсчета статистики среднего значения времени выполнения первые запуски опытов были скрещены чтобы исключить погрешность вызванная задержкой при первом запуске а также для выполнения прогрева кэша центрального процессора.

Также была замеряна средняя задержка при первом запуске на разных платформах. Для кода в режиме интерпретации задержка была меньше 1 миллисекунды, что связано с только с прогревом кэша, так как подобный режим исполнения не требует сложной инициализации и компиляции.

Для кода на JavaScript время инициализации составило в среднем 9 миллисекунд, а для WebAssembly в среднем 4 миллисекунды. Инициализация WebAssembly байт-кода занимает меньше времени, так как этот формат фактические является синтаксическим деревом кода программы и требует только компиляцию в машинный код. В свою очередь  код на JavaScript является человекочитаемым и поэтому предварительно требует разбора (парсинга) и построения синтаксического дерева и далее компиляции в машинный код. Эти данные могут быть использованы при анализе времени отклика и "холодного" старта приложения.